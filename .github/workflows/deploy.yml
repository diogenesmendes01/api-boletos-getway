# .github/workflows/deploy.yml
name: Deploy API Boletos Gateway

on:
  push:
    branches:
      - main
      - master
      - develop
    tags:
      - 'v*.*.*'
  pull_request:
    branches:
      - main
      - master

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/api-boletos-getway
  VPS_IP: 168.231.92.229
  PROJECT_DIR: /opt/api-boletos-getway

jobs:
  test:
    name: Tests and Quality Check
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout cÃ³digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Para versionamento semÃ¢ntico

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Instalar dependÃªncias
        run: npm ci

      - name: Executar Linter
        run: npm run lint

      - name: Executar testes
        run: |
          if npm test; then
            echo "âœ… Testes passaram com sucesso"
          else
            echo "::error::Testes falharam - verifique os erros acima"
            exit 1
          fi

      - name: Build do projeto
        run: |
          npm run build
          echo "âœ… Build concluÃ­do com sucesso"

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            coverage/
            test-results/
          retention-days: 7

  version:
    name: Generate Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      
    steps:
      - name: Checkout cÃ³digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate version
        id: version
        run: |
          # Se for uma tag semÃ¢ntica, usa ela
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
            echo "ðŸ·ï¸ Tag semÃ¢ntica detectada: ${VERSION}"
          # Se for main/master, usa latest
          elif [[ "${{ github.ref }}" == refs/heads/main ]] || [[ "${{ github.ref }}" == refs/heads/master ]]; then
            VERSION="latest"
            echo "ðŸŒ¿ Branch principal: ${VERSION}"
          # Para outras branches, usa o nome da branch + short SHA
          else
            BRANCH=${GITHUB_REF#refs/heads/}
            SHORT_SHA=$(echo $GITHUB_SHA | cut -c1-7)
            VERSION="${BRANCH}-${SHORT_SHA}"
            echo "ðŸŒ¿ Branch de desenvolvimento: ${VERSION}"
          fi
          
          # ValidaÃ§Ã£o de versÃ£o semÃ¢ntica
          if [[ "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "âœ… VersÃ£o semÃ¢ntica vÃ¡lida: ${VERSION}"
            SEMVER_MAJOR=$(echo $VERSION | cut -d. -f1 | sed 's/v//')
            SEMVER_MINOR=$(echo $VERSION | cut -d. -f2)
            SEMVER_PATCH=$(echo $VERSION | cut -d. -f3)
            
            # Gerar tags adicionais para compatibilidade
            echo "major=${SEMVER_MAJOR}" >> $GITHUB_OUTPUT
            echo "minor=${SEMVER_MAJOR}.${SEMVER_MINOR}" >> $GITHUB_OUTPUT
            echo "patch=${SEMVER_PATCH}" >> $GITHUB_OUTPUT
          fi
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Version: ${VERSION}"

  build-and-push:
    name: Build and Push Docker Image
    needs: [test, version]
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    
    permissions:
      contents: read
      packages: write

    outputs:
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v4

      - name: Login no GitHub Container Registry
        uses: docker/login-action@v4
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if image exists
        id: check-image
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version.outputs.version }}"
          if docker manifest inspect ${IMAGE} > /dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "â© Imagem jÃ¡ existe: ${IMAGE}"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ðŸ†• Nova imagem serÃ¡ criada: ${IMAGE}"
          fi

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v6
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=${{ needs.version.outputs.version }}
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,prefix={{branch}}-

      - name: Build and Push
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            BUILD_VERSION=${{ needs.version.outputs.version }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            COMMIT_SHA=${{ github.sha }}

  deploy:
    name: Deploy to Production
    needs: [build-and-push, version]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    environment:
      name: production
      url: https://api.envio-boleto.olympiabank.xyz

    steps:
      - name: Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: Preparar arquivos de deploy
        run: |
          # Criar diretÃ³rio temporÃ¡rio para deploy
          mkdir -p deploy-package
          
          # Copiar arquivos necessÃ¡rios
          cp docker-compose.prod.yml deploy-package/
          cp -r scripts/ deploy-package/scripts/
          
          # Criar arquivo de versÃ£o
          echo "${{ needs.version.outputs.version }}" > deploy-package/VERSION
          echo "${{ github.sha }}" > deploy-package/COMMIT
          echo "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > deploy-package/DEPLOY_TIME

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ env.VPS_IP }} >> ~/.ssh/known_hosts

      - name: Enviar arquivos de deploy
        uses: appleboy/scp-action@v0.1.8
        with:
          host: ${{ env.VPS_IP }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          source: "deploy-package/*"
          target: "${{ env.PROJECT_DIR }}"
          overwrite: true
          strip_components: 1

      - name: Backup atual antes do deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.VPS_IP }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            set -euo pipefail
            
            BACKUP_DIR="${{ env.PROJECT_DIR }}/backups/$(date +%Y%m%d_%H%M%S)"
            mkdir -p "${BACKUP_DIR}"
            
            # Salvar versÃ£o atual
            if docker ps --format "{{.Names}}" | grep -q "api-boleto-olympia"; then
              docker inspect api-boleto-olympia --format='{{.Config.Image}}' > "${BACKUP_DIR}/previous_version.txt" || true
              docker logs --tail 1000 api-boleto-olympia > "${BACKUP_DIR}/last_logs.txt" 2>&1 || true
            fi
            
            echo "âœ… Backup criado em ${BACKUP_DIR}"

      - name: Deploy Application
        id: deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.VPS_IP }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          command_timeout: 10m
          script: |
            set -euo pipefail
            
            echo "================================================"
            echo "ðŸš€ INICIANDO DEPLOY AUTOMATIZADO"
            echo "ðŸ“¦ VersÃ£o: ${{ needs.version.outputs.version }}"
            echo "ðŸ”§ Commit: ${{ github.sha }}"
            echo "================================================"
            
            cd ${{ env.PROJECT_DIR }}
            
            # Garantir permissÃµes dos scripts
            chmod +x scripts/*.sh
            
            # Executar deploy com a nova versÃ£o
            export DEPLOY_VERSION="${{ needs.version.outputs.version }}"
            export DEPLOY_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${DEPLOY_VERSION}"
            
            # Login no registry (se necessÃ¡rio)
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Executar script de deploy otimizado
            ./scripts/deploy-prod.sh

      - name: Health Check
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.VPS_IP }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            set -euo pipefail
            
            echo "ðŸ¥ Executando health checks..."
            
            cd ${{ env.PROJECT_DIR }}
            
            # Usar script de health check inteligente
            if [ -f "scripts/health-check.sh" ]; then
              chmod +x scripts/health-check.sh
              ./scripts/health-check.sh quick
            else
              echo "âš ï¸ Script de health check nÃ£o encontrado, usando mÃ©todo padrÃ£o"
              
              # Fallback para mÃ©todo anterior
              MAX_ATTEMPTS=24
              ATTEMPT=0
              
              while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                if curl -f -s "http://localhost:3001/v1/health" > /dev/null; then
                  echo "âœ… AplicaÃ§Ã£o estÃ¡ saudÃ¡vel!"
                  curl -s "http://localhost:3001/v1/health" | jq '.' || true
                  exit 0
                fi
                
                ATTEMPT=$((ATTEMPT + 1))
                echo "â³ Tentativa $ATTEMPT/$MAX_ATTEMPTS - Aguardando aplicaÃ§Ã£o..."
                sleep 5
              done
              
              echo "âŒ AplicaÃ§Ã£o nÃ£o respondeu apÃ³s 2 minutos"
              exit 1
            fi

      - name: Rollback on Failure
        if: failure() && steps.deploy.outcome == 'failure'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.VPS_IP }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            echo "ðŸ”„ INICIANDO ROLLBACK..."
            cd ${{ env.PROJECT_DIR }}
            
            # Executar script de rollback
            if [ -f scripts/rollback.sh ]; then
              ./scripts/rollback.sh
            else
              echo "âš ï¸ Script de rollback nÃ£o encontrado"
              # Tentar reverter para Ãºltima versÃ£o conhecida
              docker compose -f docker-compose.prod.yml down
              docker compose -f docker-compose.prod.yml up -d
            fi

      - name: Notify Deployment Status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… Deploy realizado com sucesso!"
            echo "ðŸ“¦ VersÃ£o: ${{ needs.version.outputs.version }}"
            echo "ðŸŒ URL: https://api.envio-boleto.olympiabank.xyz"
          else
            echo "âŒ Deploy falhou - verifique os logs"
          fi

  cleanup:
    name: Cleanup Old Resources
    needs: deploy
    runs-on: ubuntu-latest
    if: success()
    
    steps:
      - name: Cleanup old images on VPS
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.VPS_IP }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            echo "ðŸ§¹ Limpando recursos antigos..."
            
            # Manter apenas as Ãºltimas 3 imagens
            docker images ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} --format "{{.Tag}}\t{{.ID}}" | \
              tail -n +4 | awk '{print $2}' | xargs -r docker rmi -f || true
            
            # Limpar containers parados
            docker container prune -f
            
            # Limpar imagens nÃ£o utilizadas (mas preservar volumes)
            docker image prune -f
            
            # Limpar logs antigos (mais de 7 dias)
            find ${{ env.PROJECT_DIR }}/logs -type f -mtime +7 -delete 2>/dev/null || true
            
            # Limpar backups antigos (mais de 30 dias)
            find ${{ env.PROJECT_DIR }}/backups -type d -mtime +30 -exec rm -rf {} + 2>/dev/null || true
            
            echo "âœ… Limpeza concluÃ­da"